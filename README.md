# 3.2. Создание API. Swagger UI, Postman

Цели работы: 1) создать полноценное RESTful-приложение, используя структуры model, service, controller; 2) добавить эндпоинты для CRUD-операций над сущностями; добавить swagger и протестировать с помощью Postman.

**Шаг 1**

Создать простое SpringBoot-приложение. В качестве группы и артефакта проекта можно использовать следующие значения: groupId — ru.hogwarts, artifact — school.

**Шаг 2**

1. Создать каталоги model, service, controller в пакете ru.hogwarts.school. В model создать два класса: Student, Faculty. 

Класс **Student** имеет следующие поля: **Long id, String name, int age.** 

Класс **Faculty** имеет следующие поля: **Long id, String name, String color.**

1. Добавить конструкторы к классам, с помощью которых можно проинициализировать все поля (создать объект класса через new и передать в него все параметры). 
2. Создать методы для получения и изменения переменных класса. Сами переменные должны быть private. 

Если есть желание, можно добавить свои поля, которые могут быть вам необходимы.

**Шаг 3**

1. В каталоге **service** cоздать два класса сервисов для моделей: StudentService и FacultyService. 
2. В каждом из них завести HashMap, в котором следует хранить модели. Например Map<Long, Student>. 
3. Также создать счетчик идентификатора, который будет инкрементироваться при каждом добавлении нового объекта модели в HashMap. 
4. В каждом сервисе реализовать CRUD-методы для создания, чтения, изменения и удаления сущностей.

**Шаг 4**

1. В каталоге **controller** cоздать два класса контроллеров для сервисов: StudentController и FacultyController. 
2. В них добавить RequestMapping (“student” для StudentController и “faculty” для FacultyController). 
3. В каждом контроллере реализовать эндпоинты для создания, получения, изменения и удаления сущностей, используя все правила формирования REST-запросов: GET-методы для получения данных, POST — для создания…

**Шаг 5**

1. Добавить фильтрацию студентов по возрасту. 

Для этого в StudentController добавить эндпоинт, который принимает число (возраст — поле age) и возвращает список студентов, у которых совпал возраст с переданным числом.

1. Добавить фильтрацию факультетов по цвету. 

Для этого в FacultyController добавить эндпоинт, который принимает строку (цвет — поле color) и возвращает список факультетов, у которых совпал цвет с переданной строкой.

**Шаг 6**

Добавить swagger к проекту. Для этого добавить зависимость к проекту.

**Шаг 7**

Установить Postman и вызвать все эндпоинты проекта, используя его.

# 3.3. Введение в базы данных

Цель работы — установить и настроить взаимодействие приложения с базой данных и изменить логику в сервисных классах, чтобы все изменения сохранялись в БД.

**Шаг 1**

Установить БД PostgreSQL. Создать базу данных hogwarts. Создать пользователя student с паролем chocolatefrog.

**Шаг 2**

В application.properties приложения прописать следующие атрибуты:

- spring.datasource.url — путь до установленной БД;
- spring.datasource.username — имя пользователя для подключения, в нашем случае это student;
- spring.datasource.password — пароль пользователя: chocolatefrog;
- spring.jpa.hibernate.ddl = update.

**Шаг 3**

Изменить модели Student и Faculty. К каждому классу добавить аннотацию @Entity. А к полю id добавить две аннотации: @Id и @GeneratedValue.

А также создать пакет repository, в котором будут находиться два интерфейса: StudentRepository и FacultyRepository. Оба этих интерфейса наследуют JpaRepository. Для интерфейса StudentRepository требуется указать, что в JpaRepository надо работать с моделью Student. Для FacultyRepository указать Faculty.

**Шаг 4**

В сервисах создать приватные поля репозиториев. Для StudentService создать StudentRepository. Для FacultyService создать FacultyRepository. С помощью конструкторов подтягивать зависимости из контекста спринга (@Autowire).

В сервисах удалить HashMap, который использовали для хранения данных, и удалить счетчик идентификатора. Вместо них следует использовать функционал репозиториев.

**Шаг 5**

Проверить все CRUD-запросы через Postman.

# 3.4. Введение в SQL

Цель сегодняшней домашней работы — углубиться в язык запросов SQL и написать несколько SELECT-методов. А также установить связь ManyToOne между факультетами и студентами.

**Шаг 1**

Добавить эндпоинт для получения всех студентов, возраст которых находится в промежутке, пришедшем в запросе, т. е. в GET-запросе будут передаваться два числа (min и max). Для этого в репозитории следует создать метод findByAgeBetween().

Добавить эндпоинт для поиска факультета по имени или цвету, игнорируя регистр, т. е. в GET-запросе будет передана строка, по которой будет происходить фильтрация.

**Шаг 2**

Подключиться с помощью IDEA к базе данных и выполнить простой запрос select * from student.

**Шаг 3**

Составить следующие SQL-запросы:

1. Получить всех студентов, возраст которых находится между 10 и 20 (можно подставить любые числа, главное, чтобы нижняя граница была меньше верхней).
2. Получить всех студентов, но отобразить только список их имен.
3. Получить всех студентов, у которых в имени присутствует буква «О» (или любая другая).
4. Получить всех студентов, у которых возраст меньше идентификатора.
5. Получить всех студентов упорядоченных по возрасту.

В корне проекта создать файл scripts.sql и поместить в него составленные запросы.

**Шаг 4**

Настроить связь ManyToOne между студентами и факультетом. При этом у модели студента должно быть создано поле Faculty, а у модели факультета — список студентов.

Добавить два эндпоинта в соответствующие контроллеры которые позволят:

1. Получить факультет студента
2. Получить студентов факультета

# 3.5. Потоки данных. Работа с файлами

Цель задания — научиться работать с файлами (загружать их и отдавать в запросах) и со связями OneToOne.

**Шаг 1**

Создать модель Avatar. В ней будем хранить аватарки студентов. В модель добавить следующие поля: Long id, String filePath, long fileSize, String mediaType, byte[] data, Student student.

**Шаг 2**

Настроить связь OneToOne между моделями Student и Avatar. Для этого к полю student в модели Avatar добавить аннотацию @OneToOne. Добавить контроллер, сервис и репозиторий для работы с моделью Avatar.

**Шаг 3**

Добавить три эндпоинта. Первый для загрузки картинки. При загрузке должно происходить сохранение данных как в БД, так и на локальный диск. Второй эндпоинт должен возвращать картинку из БД. Третий должен возвращать картинку из директории.

# 3.6. Тестирование веб-приложений в Spring Boot

Цель работы — научиться писать тесты для приложений Spring Boot двумя способами: используя TestRestTemplate и используя WebMvcTest.

**Шаг 1**

Создать класс для тестирования в пакете test. Создать по одному тесту на каждый эндпоинт контроллера StudentController, используя WebMvcTest.

**Шаг 2**

Создать еще один класс для тестирования в пакете test. Создать по одному тесту на каждый эндпоинт контроллера FacultyController, используя WebMvcTest.

# 4.1. *Продолжение знакомства с SQL*

В домашнем задании нам предстоит добавить больше функционала в проект путем добавления новых эндпоинтов. Эти эндпоинты будут использовать методы репозиториев, которые, в свою очередь, будут выполнять SQL-выражения из Java. А также настроим пагинацию для аватарок.

**Шаг 1.** Использование аннотации @Query для вызова SQL из приложения.

Используйте аннотацию @Query и добавьте следующий функционал в проект:

- Возможность получить количество всех студентов в школе. Эндпоинт должен вернуть число.
- Возможность получить средний возраст студентов. Эндпоинт должен вернуть число.
- Возможность получать только пять последних студентов. Последние студенты считаются теми, у кого идентификатор больше других.

**Шаг 2.** Добавление пагинации к аватаркам.

Добавьте пагинацию для репозитория AvatarRepository и контроллер в AvatartController, чтобы можно было получать списки аватарок постранично.

# 4.2. *Управление схемами баз данных*

Цель работы — создать ограничения для таблиц нашего проекта, выполнить нормализацию предложенного примера, а также написать скрипт для создания структуры БД.

**Шаг 1**

С прошлых уроков у нас есть две таблицы: Student и Faculty. Необходимо для них создать следующие ограничения:

- Возраст студента не может быть меньше 16 лет.
- Имена студентов должны быть уникальными и не равны нулю.
- Пара “значение названия” - “цвет факультета” должна быть уникальной.
- При создании студента без возраста ему автоматически должно присваиваться 20 лет.

В корне проекта нужно создать файл scripts421.sql (что значит 4-й курс, 2-й урок, 1-е задание) и поместить в него запросы для создания ограничений.

**Шаг 2**

В этом задании по описанию необходимо спроектировать таблицы, связи между ними и корректно определить типы данных. Здесь не важно, какой тип вы выберете, например, для данных, представленных в виде строки (varchar или text). Важно, что вы выберете один из строковых типов, а не числовых, например.

Описание структуры: у каждого человека есть машина. Причем несколько человек могут пользоваться одной машиной. У каждого человека есть имя, возраст и признак того, что у него есть права (или их нет). У каждой машины есть марка, модель и стоимость. Также не забудьте добавить таблицам первичные ключи и связать их.

В корне проекта нужно создать файл scripts422.sql и поместить в него запросы для создания таблиц.

**Шаг 3**

Составить первый JOIN-запрос, чтобы получить информацию обо всех студентах (достаточно получить только имя и возраст студента) школы Хогвартс вместе с названиями факультетов.

Составить второй JOIN-запрос, чтобы получить только тех студентов, у которых есть аватарки.

В корне проекта создать файл scripts422.sql и поместить в него запрос.

# 4.3. Миграции и индексы

Цель работы — создать несколько миграций для добавления индексов. Настройку миграций будем осуществлять с помощью Liquibase. В дальнейшем мы будем использовать Liquibase для всех операций с БД

**Шаг 1**

Добавить Liquibase к проекту. Создать файл для миграций с любым говорящим названием, которое относится к текущему уроку. В качестве названия можно использовать, например: lesson-three, course-four-lesson-three, index-practice и т.д.

**Шаг 2**

Добавить два индекса, используя миграции:
1) Индекс для поиска по имени студента.
2) Индекс для поиска по названию и цвету факультета.
